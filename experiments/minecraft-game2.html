<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel World - Mega Edition (Full Preload)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #eee;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        #canvas-container {
            flex: 1;
            position: relative;
            cursor: crosshair;
        }
        #canvas-container.locked { cursor: none; }
        canvas { display: block; width: 100%; height: 100%; }

        #ui {
            width: 260px;
            background: #16213e;
            padding: 15px;
            overflow-y: auto;
        }
        h1 { font-size: 1.2em; margin-bottom: 5px; color: #4ecca3; }
        .subtitle { font-size: 0.75em; color: #888; margin-bottom: 15px; }
        h2 {
            font-size: 0.85em;
            margin: 12px 0 8px;
            color: #0f3460;
            background: #4ecca3;
            padding: 5px 10px;
            border-radius: 4px;
        }
        .stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.8em;
        }
        .stat-label { color: #888; }
        .stat-value { color: #4ecca3; font-family: 'Consolas', monospace; }
        .stat-value.highlight { color: #ffd700; font-weight: bold; }
        .stat-value.flying { color: #00bfff; font-weight: bold; text-shadow: 0 0 8px #00bfff; }
        .stat-value.mega { color: #ff6b6b; font-weight: bold; text-shadow: 0 0 8px #ff6b6b; }
        .info {
            background: #0f3460;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.75em;
            line-height: 1.6;
            margin-top: 12px;
        }
        .key {
            display: inline-block;
            background: #e94560;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
            margin: 1px;
            font-size: 0.85em;
        }

        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #overlay.hidden { opacity: 0; }
        #overlay h2 {
            background: none;
            color: #fff;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #overlay p { color: #aaa; margin-top: 10px; }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .crosshair.visible { opacity: 0.8; }
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: #fff;
        }
        .crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        .crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0,0,0,0.95);
            padding: 40px 50px;
            border-radius: 12px;
            z-index: 100;
        }
        #loading h2 {
            background: none;
            color: #4ecca3;
            font-size: 1.4em;
            margin-bottom: 20px;
        }
        #loading-progress {
            width: 320px;
            height: 24px;
            background: #0f3460;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        #loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #4ecca3, #ffd700);
            width: 0%;
            transition: width 0.05s ease;
        }
        #loading-text { color: #888; font-size: 0.9em; }
        #loading-stats {
            color: #666;
            font-size: 0.75em;
            margin-top: 10px;
            font-family: 'Consolas', monospace;
        }

        .hidden { display: none !important; }

        #respawn-message {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(233, 69, 96, 0.9);
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.2em;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        #respawn-message.visible { opacity: 1; }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>

            <div id="loading">
                <h2>üåç Generating FULL MEGA World...</h2>
                <div id="loading-progress">
                    <div id="loading-bar"></div>
                </div>
                <div id="loading-text">Initializing...</div>
                <div id="loading-stats"></div>
            </div>

            <div id="overlay" class="hidden">
                <h2>Click to Play</h2>
                <p>WASD to move, SPACE to jump, Mouse to look</p>
            </div>

            <div class="crosshair"></div>
            <div id="respawn-message">Respawning...</div>
        </div>

        <div id="ui">
            <h1>üéÆ Voxel World</h1>
            <div class="subtitle">MEGA Edition - Full Preload</div>

            <h2>üë§ Player</h2>
            <div class="stat">
                <span class="stat-label">Position</span>
                <span class="stat-value" id="player-pos">(0, 0, 0)</span>
            </div>
            <div class="stat">
                <span class="stat-label">Chunk</span>
                <span class="stat-value" id="player-chunk">(0, 0)</span>
            </div>
            <div class="stat">
                <span class="stat-label">On Ground</span>
                <span class="stat-value" id="on-ground">No</span>
            </div>
            <div class="stat">
                <span class="stat-label">Flying</span>
                <span class="stat-value" id="flying-status">No</span>
            </div>

            <h2>üåç World</h2>
            <div class="stat">
                <span class="stat-label">World Size</span>
                <span class="stat-value mega" id="world-size">4096¬≥</span>
            </div>
            <div class="stat">
                <span class="stat-label">Total Chunks</span>
                <span class="stat-value highlight" id="chunk-count">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Voxels</span>
                <span class="stat-value" id="voxel-count">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Active Bricks</span>
                <span class="stat-value" id="brick-count">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Memory</span>
                <span class="stat-value" id="memory-usage">0 MB</span>
            </div>
            <div class="stat">
                <span class="stat-label">Load Time</span>
                <span class="stat-value" id="load-time">-</span>
            </div>

            <h2>üìä Performance</h2>
            <div class="stat">
                <span class="stat-label">FPS</span>
                <span class="stat-value highlight" id="fps">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Frame Time</span>
                <span class="stat-value" id="frame-time">0 ms</span>
            </div>

            <div class="info">
                <strong>Controls:</strong><br>
                <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> Move<br>
                <span class="key">SPACE</span> Jump / Fly Up<br>
                <span class="key">SHIFT</span> Sprint / Fly Down<br>
                <span class="key">F</span> Toggle Flight ‚úàÔ∏è<br>
                <span class="key">Mouse</span> Look around<br>
                <span class="key">ESC</span> Release cursor
            </div>
        </div>
    </div>

    <script src="../engine.js"></script>

    <script>
    // ============================================================
    // Terrain Generator - Surface voxels only (MEGA WORLD)
    // ============================================================
    class TerrainGenerator {
        constructor(seed = 12345) {
            this.seed = seed;
            this.baseHeight = 30;
            this.hillHeight = 35;
            this.scale = 0.008;
        }

        noise2D(x, z, scale, seed) {
            const nx = x * scale + seed;
            const nz = z * scale + seed * 1.5;
            return (Math.sin(nx) * Math.cos(nz) +
                    Math.sin(nx * 2.1 + 0.5) * Math.cos(nz * 1.9 + 0.3) * 0.5 +
                    Math.sin(nx * 4.3 + 1.2) * Math.cos(nz * 3.7 + 0.7) * 0.25) / 1.75;
        }

        getHeight(x, z) {
            const n1 = this.noise2D(x, z, this.scale, this.seed);
            const n2 = this.noise2D(x, z, this.scale * 2, this.seed + 1000) * 0.5;
            const n3 = this.noise2D(x, z, this.scale * 4, this.seed + 2000) * 0.25;
            let baseH = this.baseHeight + Math.floor(((n1 + n2 + n3) / 1.75 * 0.5 + 0.5) * this.hillHeight);

            // Multiple mountains scattered across the mega world
            // First mountain is at exact center (0,0), others spread throughout avoiding borders
            const mountains = [
                { x: 0, z: 0, radius: 70, height: 80 },           // Center mountain - player spawn
                { x: 400, z: 300, radius: 80, height: 90 },       // Northeast
                { x: -350, z: 450, radius: 50, height: 55 },      // Northwest
                { x: 500, z: -400, radius: 70, height: 75 },      // Southeast
                { x: -400, z: -350, radius: 45, height: 50 },     // Southwest
                { x: 600, z: 600, radius: 100, height: 110 },     // Far northeast
                { x: -550, z: -500, radius: 65, height: 65 },     // Far southwest
                { x: -600, z: 200, radius: 55, height: 60 },      // West
                { x: 250, z: -600, radius: 60, height: 70 },      // South
            ];

            for (const mountain of mountains) {
                const dx = x - mountain.x;
                const dz = z - mountain.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < mountain.radius) {
                    const normalizedDist = dist / mountain.radius;
                    const heightFactor = Math.pow(Math.cos(normalizedDist * Math.PI / 2), 1.3);
                    const rockNoise = this.noise2D(x, z, 0.15, this.seed + 5000) * 3;
                    baseH += Math.floor(heightFactor * mountain.height + rockNoise);
                }
            }

            return baseH;
        }

        pseudoRandom(seed) {
            const x = Math.sin(seed * 12.9898 + 78.233) * 43758.5453;
            return x - Math.floor(x);
        }

        isOnMountain(x, z) {
            const mountains = [
                { x: 0, z: 0, radius: 70 },
                { x: 400, z: 300, radius: 80 },
                { x: -350, z: 450, radius: 50 },
                { x: 500, z: -400, radius: 70 },
                { x: -400, z: -350, radius: 45 },
                { x: 600, z: 600, radius: 100 },
                { x: -550, z: -500, radius: 65 },
                { x: -600, z: 200, radius: 55 },
                { x: 250, z: -600, radius: 60 },
            ];

            for (const mountain of mountains) {
                const dx = x - mountain.x;
                const dz = z - mountain.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < mountain.radius) return true;
            }
            return false;
        }

        generateChunk(world, chunkX, chunkZ, chunkSize, worldOffset) {
            const startX = worldOffset + chunkX * chunkSize;
            const startZ = worldOffset + chunkZ * chunkSize;

            if (startX < 0 || startX + chunkSize > world.worldSize ||
                startZ < 0 || startZ + chunkSize > world.worldSize) {
                return false;
            }

            const heights = new Int32Array(chunkSize * chunkSize);
            for (let lx = 0; lx < chunkSize; lx++) {
                for (let lz = 0; lz < chunkSize; lz++) {
                    const noiseX = chunkX * chunkSize + lx;
                    const noiseZ = chunkZ * chunkSize + lz;
                    heights[lx + lz * chunkSize] = this.getHeight(noiseX, noiseZ);
                }
            }

            for (let lx = 0; lx < chunkSize; lx++) {
                for (let lz = 0; lz < chunkSize; lz++) {
                    const h = heights[lx + lz * chunkSize];
                    const wx = startX + lx;
                    const wz = startZ + lz;
                    const noiseX = chunkX * chunkSize + lx;
                    const noiseZ = chunkZ * chunkSize + lz;

                    const isOnMountain = this.isOnMountain(noiseX, noiseZ);

                    const getH = (dx, dz) => {
                        const nx = lx + dx, nz = lz + dz;
                        if (nx >= 0 && nx < chunkSize && nz >= 0 && nz < chunkSize)
                            return heights[nx + nz * chunkSize];
                        return this.getHeight(noiseX + dx, noiseZ + dz);
                    };

                    const neighborHeights = [
                        getH(-1, 0), getH(1, 0), getH(0, -1), getH(0, 1),
                        getH(-1, -1), getH(-1, 1), getH(1, -1), getH(1, 1),
                        getH(-2, 0), getH(2, 0), getH(0, -2), getH(0, 2)
                    ];
                    const minH = Math.min(...neighborHeights);

                    const heightDiff = h - minH;
                    const extraDepth = Math.max(3, heightDiff + 2);
                    const startY = Math.max(0, h - extraDepth);

                    for (let y = startY; y < h; y++) {
                        let r, g, b;

                        if (isOnMountain && y > 80) {
                            if (y === h - 1) {
                                const snow = 240 + (this.pseudoRandom(noiseX*1000+noiseZ+y) * 15)|0;
                                r = snow; g = snow; b = snow + 5;
                            } else {
                                const snow = 220 + (this.pseudoRandom(noiseX*1000+noiseZ+y) * 20)|0;
                                r = snow; g = snow; b = snow + 10;
                            }
                        } else if (isOnMountain && y > 55) {
                            const rockVar = this.pseudoRandom(noiseX*1000+noiseZ+y);
                            if (rockVar > 0.6) {
                                r = 85 + (this.pseudoRandom(noiseX+noiseZ+y) * 20)|0;
                                g = 80 + (this.pseudoRandom(noiseX+noiseZ+y+1) * 15)|0;
                                b = 75 + (this.pseudoRandom(noiseX+noiseZ+y+2) * 15)|0;
                            } else {
                                r = 120 + (this.pseudoRandom(noiseX+noiseZ+y) * 25)|0;
                                g = 115 + (this.pseudoRandom(noiseX+noiseZ+y+1) * 20)|0;
                                b = 105 + (this.pseudoRandom(noiseX+noiseZ+y+2) * 20)|0;
                            }
                        } else if (y === h - 1) {
                            r = 74 + (this.pseudoRandom(noiseX*1000+noiseZ+y) * 20)|0;
                            g = 124 + (this.pseudoRandom(noiseX*1000+noiseZ+y+1) * 20)|0;
                            b = 69 + (this.pseudoRandom(noiseX*1000+noiseZ+y+2) * 20)|0;
                        } else if (y > h - 4) {
                            r = 139 + (this.pseudoRandom(noiseX*1000+noiseZ+y) * 15)|0;
                            g = 90 + (this.pseudoRandom(noiseX*1000+noiseZ+y+1) * 15)|0;
                            b = 60 + (this.pseudoRandom(noiseX*1000+noiseZ+y+2) * 10)|0;
                        } else {
                            const shade = (this.pseudoRandom(noiseX*1000+noiseZ+y) * 20)|0;
                            r = 100 + shade; g = 100 + shade; b = 105 + shade;
                        }
                        world.setVoxel(wx, y, wz, r, g, b);
                    }
                }
            }

            // Trees
            const treeSeed = this.seed + chunkX * 1000 + chunkZ;
            const numTrees = 3 + Math.floor(this.pseudoRandom(treeSeed) * 4);

            for (let i = 0; i < numTrees; i++) {
                const lx = Math.floor(this.pseudoRandom(treeSeed + i * 100) * (chunkSize - 8)) + 4;
                const lz = Math.floor(this.pseudoRandom(treeSeed + i * 100 + 50) * (chunkSize - 8)) + 4;
                const groundY = heights[lx + lz * chunkSize];

                if (groundY < 15 || groundY > 60) continue;

                const wx = startX + lx;
                const wz = startZ + lz;
                const treeH = 5 + Math.floor(this.pseudoRandom(treeSeed + i * 200) * 4);

                for (let y = groundY; y < groundY + treeH; y++) {
                    world.setVoxel(wx, y, wz,
                        93 + (this.pseudoRandom(i+y)*10)|0,
                        64 + (this.pseudoRandom(i+y+1)*10)|0,
                        45 + (this.pseudoRandom(i+y+2)*10)|0);
                }

                const leafY = groundY + treeH - 2;
                for (let dy = 0; dy <= 3; dy++) {
                    const r = dy < 2 ? 2 : 1;
                    for (let dx = -r; dx <= r; dx++) {
                        for (let dz = -r; dz <= r; dz++) {
                            if (Math.abs(dx) === r && Math.abs(dz) === r && dy < 2) continue;
                            if (dx === 0 && dz === 0 && dy < 2) continue;
                            world.setVoxel(wx + dx, leafY + dy, wz + dz,
                                36 + (this.pseudoRandom(i+dx+dz+dy)*20)|0,
                                115 + (this.pseudoRandom(i+dx+dz+dy+1)*30)|0,
                                40 + (this.pseudoRandom(i+dx+dz+dy+2)*20)|0);
                        }
                    }
                }
            }

            // Flowers
            const flowerSeed = treeSeed + 5000;
            const flowers = [[255,50,50], [255,255,50], [255,150,200], [150,150,255], [255,165,0]];
            const numFlowers = 6 + Math.floor(this.pseudoRandom(flowerSeed) * 12);

            for (let i = 0; i < numFlowers; i++) {
                const lx = Math.floor(this.pseudoRandom(flowerSeed + i * 100) * chunkSize);
                const lz = Math.floor(this.pseudoRandom(flowerSeed + i * 100 + 50) * chunkSize);
                const h = heights[lx + lz * chunkSize];
                const c = flowers[Math.floor(this.pseudoRandom(flowerSeed + i) * flowers.length)];
                world.setVoxel(startX + lx, h, startZ + lz, c[0], c[1], c[2]);
            }

            return true;
        }
    }

    // ============================================================
    // Player with physics
    // ============================================================
    class Player {
        constructor() {
            this.x = 0; this.y = 50; this.z = 0;
            this.vx = 0; this.vy = 0; this.vz = 0;
            this.yaw = 0; this.pitch = 0;
            this.width = 0.6; this.height = 1.8; this.eyeHeight = 1.6;
            this.onGround = false;
            this.walkSpeed = 6; this.sprintSpeed = 10;
            this.flySpeed = 40;  // Even faster for full world exploration
            this.jumpForce = 8; this.gravity = 25;
            this.spawnX = 0; this.spawnY = 50; this.spawnZ = 0;
            this.flying = false;
        }

        setSpawn(x, y, z) { this.spawnX = x; this.spawnY = y; this.spawnZ = z; }
        respawn() { this.x = this.spawnX; this.y = this.spawnY; this.z = this.spawnZ; this.vx = this.vy = this.vz = 0; this.flying = false; }
        getEyePos() { return [this.x, this.y + this.eyeHeight, this.z]; }
        getForward() { return [Math.sin(this.yaw), Math.cos(this.yaw)]; }
        getRight() { return [Math.cos(this.yaw), -Math.sin(this.yaw)]; }

        toggleFlight() {
            this.flying = !this.flying;
            if (this.flying) this.vy = 0;
        }

        rotate(dy, dp) {
            this.yaw += dy;
            this.pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, this.pitch - dp));
        }

        jump() { if (this.onGround && !this.flying) { this.vy = this.jumpForce; this.onGround = false; } }
    }

    // ============================================================
    // Main Game - FULL WORLD PRELOAD
    // ============================================================
    class VoxelGame {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.engine = new VoxelEngine(this.canvas);
            this.player = new Player();
            this.terrain = new TerrainGenerator(Math.floor(Math.random() * 100000));

            this.chunkSize = 32;
            this.loadedChunks = new Set();
            this.worldOffset = 0;
            this.loadTime = 0;

            this.keys = {};
            this.isLocked = false;
            this.mouseDelta = { x: 0, y: 0 };
            this.fps = 0;
            this.frameCount = 0;
            this.lastFpsTime = performance.now();

            this._setupInput();
        }

        _setupInput() {
            window.addEventListener('keydown', e => {
                if (this.keys[e.code]) return;
                this.keys[e.code] = true;
                if (e.code === 'Space') { e.preventDefault(); this.player.jump(); }
                if (e.code === 'KeyF') { this.player.toggleFlight(); }
                if (e.code === 'Escape' && this.isLocked) document.exitPointerLock();
            });
            window.addEventListener('keyup', e => this.keys[e.code] = false);
            this.canvas.addEventListener('click', () => {
                if (!this.isLocked) this.canvas.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => {
                this.isLocked = document.pointerLockElement === this.canvas;
                document.getElementById('overlay').classList.toggle('hidden', this.isLocked);
                document.querySelector('.crosshair').classList.toggle('visible', this.isLocked);
                this.canvas.parentElement.classList.toggle('locked', this.isLocked);
                if (!this.isLocked) this.keys = {};
            });
            window.addEventListener('blur', () => this.keys = {});
            document.addEventListener('mousemove', e => {
                if (this.isLocked) {
                    this.mouseDelta.x += e.movementX;
                    this.mouseDelta.y += e.movementY;
                }
            });
            window.addEventListener('resize', () => this._resize());
        }

        async init() {
            const loadingBar = document.getElementById('loading-bar');
            const loadingText = document.getElementById('loading-text');
            const loadingStats = document.getElementById('loading-stats');

            const startTime = performance.now();

            const progress = (p, text, stats = '') => {
                loadingBar.style.width = (p * 100) + '%';
                loadingText.textContent = text;
                loadingStats.textContent = stats;
            };

            progress(0, 'Creating MEGA world...', '');
            await this._delay(50);

            // Create MEGA world: 512 coarse = 4096¬≥ world
            this.engine.createWorld(512, 8);
            this.worldOffset = Math.floor(this.engine.world.worldSize / 2);

            document.getElementById('world-size').textContent =
                this.engine.world.worldSize + '¬≥';

            progress(0.02, 'Calculating chunk range...', '');
            await this._delay(50);

            // Calculate full chunk range
            // World goes from 0 to worldSize, offset is worldSize/2
            // In noise coordinates, we want to cover the entire world
            const chunksPerSide = Math.floor(this.engine.world.worldSize / this.chunkSize);
            const minChunk = -Math.floor(chunksPerSide / 2);
            const maxChunk = Math.floor(chunksPerSide / 2) - 1;

            const totalChunks = chunksPerSide * chunksPerSide;
            let generated = 0;
            let lastUpdate = performance.now();

            progress(0.03, `Generating ${totalChunks.toLocaleString()} chunks...`, `${chunksPerSide}x${chunksPerSide} grid`);
            await this._delay(50);

            // Generate ALL chunks
            for (let cx = minChunk; cx <= maxChunk; cx++) {
                for (let cz = minChunk; cz <= maxChunk; cz++) {
                    const key = `${cx},${cz}`;

                    if (this.terrain.generateChunk(this.engine.world, cx, cz, this.chunkSize, this.worldOffset)) {
                        this.loadedChunks.add(key);
                    }
                    generated++;

                    // Update progress every 100ms to keep UI responsive
                    const now = performance.now();
                    if (now - lastUpdate > 100) {
                        const p = 0.03 + (generated / totalChunks) * 0.85;
                        const elapsed = ((now - startTime) / 1000).toFixed(1);
                        const chunksPerSec = Math.floor(generated / (now - startTime) * 1000);
                        const eta = ((totalChunks - generated) / chunksPerSec).toFixed(0);
                        progress(p,
                            `Chunk ${generated.toLocaleString()}/${totalChunks.toLocaleString()}`,
                            `${elapsed}s elapsed | ${chunksPerSec} chunks/s | ETA: ${eta}s`
                        );
                        lastUpdate = now;
                        await this._delay(1);
                    }
                }
            }

            const genTime = performance.now();
            progress(0.90, 'Uploading to GPU...', `Generation: ${((genTime - startTime)/1000).toFixed(1)}s`);
            await this._delay(50);

            // Full upload
            this.engine.uploadWorld();

            const uploadTime = performance.now();
            progress(0.98, 'Finding spawn...', `Upload: ${((uploadTime - genTime)/1000).toFixed(1)}s`);
            await this._delay(50);

            // Spawn on center mountain (0, 0 in noise coords = exact world center)
            const mountainCenterX = 0;
            const mountainCenterZ = 0;
            const spawnY = this.terrain.getHeight(mountainCenterX, mountainCenterZ) + 2;
            this.player.x = this.worldOffset + mountainCenterX + 0.5;
            this.player.y = spawnY;
            this.player.z = this.worldOffset + mountainCenterZ + 0.5;
            this.player.setSpawn(this.player.x, this.player.y, this.player.z);

            this.loadTime = (performance.now() - startTime) / 1000;

            progress(1, 'Ready!', `Total: ${this.loadTime.toFixed(1)}s`);
            await this._delay(500);

            document.getElementById('loading').classList.add('hidden');
            document.getElementById('overlay').classList.remove('hidden');
            document.getElementById('load-time').textContent = this.loadTime.toFixed(1) + 's';

            this.engine.settings.enableShadows = true;
            this.engine.settings.fogDensity = 0.8;  // Even less fog for full world view
            this.engine.camera.fov = 70;
            this._resize();

            console.log('=== FULL WORLD LOADED ===');
            console.log(`World size: ${this.engine.world.worldSize}¬≥`);
            console.log(`Chunks: ${this.loadedChunks.size.toLocaleString()}`);
            console.log(`Voxels: ${this.engine.getVoxelCount().toLocaleString()}`);
            console.log(`Bricks: ${this.engine.getBrickCount().toLocaleString()}`);
            console.log(`Memory: ${this.engine.getMemoryUsage().totalMB.toFixed(2)} MB`);
            console.log(`Load time: ${this.loadTime.toFixed(1)}s`);
        }

        _delay(ms) { return new Promise(r => setTimeout(r, ms)); }
        _resize() {
            const c = this.canvas.parentElement;
            this.engine.resize(c.clientWidth, c.clientHeight);
        }

        _checkCollision(x, y, z) {
            const hw = this.player.width / 2;
            const points = [
                [x-hw, y, z-hw], [x+hw, y, z-hw], [x-hw, y, z+hw], [x+hw, y, z+hw],
                [x-hw, y+0.9, z-hw], [x+hw, y+0.9, z-hw], [x-hw, y+0.9, z+hw], [x+hw, y+0.9, z+hw],
                [x-hw, y+1.8, z-hw], [x+hw, y+1.8, z-hw], [x-hw, y+1.8, z+hw], [x+hw, y+1.8, z+hw],
            ];
            for (const [px, py, pz] of points) {
                const v = this.engine.world.getVoxel(Math.floor(px), Math.floor(py), Math.floor(pz));
                if (v && v.a > 0) return true;
            }
            return false;
        }

        _isOnGround() {
            const hw = this.player.width / 2;
            const y = this.player.y - 0.1;
            const points = [
                [this.player.x-hw, y, this.player.z-hw],
                [this.player.x+hw, y, this.player.z-hw],
                [this.player.x-hw, y, this.player.z+hw],
                [this.player.x+hw, y, this.player.z+hw],
                [this.player.x, y, this.player.z],
            ];
            for (const [px, py, pz] of points) {
                const v = this.engine.world.getVoxel(Math.floor(px), Math.floor(py), Math.floor(pz));
                if (v && v.a > 0) return true;
            }
            return false;
        }

        _updatePlayer(dt) {
            if (this.player.y < -20 && !this.player.flying) {
                document.getElementById('respawn-message').classList.add('visible');
                setTimeout(() => document.getElementById('respawn-message').classList.remove('visible'), 1500);
                this.player.respawn();
                return;
            }

            this.player.rotate(this.mouseDelta.x * 0.002, this.mouseDelta.y * 0.002);
            this.mouseDelta.x = this.mouseDelta.y = 0;

            const [fx, fz] = this.player.getForward();
            const [rx, rz] = this.player.getRight();
            let mx = 0, mz = 0, my = 0;

            if (this.keys['KeyW']) { mx += fx; mz += fz; }
            if (this.keys['KeyS']) { mx -= fx; mz -= fz; }
            if (this.keys['KeyA']) { mx -= rx; mz -= rz; }
            if (this.keys['KeyD']) { mx += rx; mz += rz; }

            const len = Math.sqrt(mx*mx + mz*mz);
            if (len > 0) { mx /= len; mz /= len; }

            if (this.player.flying) {
                const speed = this.player.flySpeed;
                this.player.vx = mx * speed;
                this.player.vz = mz * speed;

                if (this.keys['Space']) { my = 1; }
                if (this.keys['ControlLeft'] || this.keys['ShiftLeft']) { my = -1; }
                this.player.vy = my * speed;
            } else {
                const speed = this.keys['ShiftLeft'] ? this.player.sprintSpeed : this.player.walkSpeed;
                this.player.vx = mx * speed;
                this.player.vz = mz * speed;
                this.player.vy -= this.player.gravity * dt;
                this.player.vy = Math.max(this.player.vy, -50);
            }

            const newX = this.player.x + this.player.vx * dt;
            const newY = this.player.y + this.player.vy * dt;
            const newZ = this.player.z + this.player.vz * dt;

            if (!this._checkCollision(newX, this.player.y, this.player.z)) {
                this.player.x = newX;
            }
            if (!this._checkCollision(this.player.x, this.player.y, newZ)) {
                this.player.z = newZ;
            }
            if (!this._checkCollision(this.player.x, newY, this.player.z)) {
                this.player.y = newY;
            } else {
                if (this.player.vy < 0) this.player.onGround = true;
                this.player.vy = 0;
            }

            this.player.onGround = this._isOnGround();

            const [ex, ey, ez] = this.player.getEyePos();
            this.engine.camera.setPosition(ex, ey, ez);
            this.engine.camera.yaw = this.player.yaw;
            this.engine.camera.pitch = this.player.pitch;
        }

        _updateStats() {
            this.frameCount++;
            const now = performance.now();
            if (now - this.lastFpsTime >= 1000) {
                this.fps = this.frameCount;
                this.frameCount = 0;
                this.lastFpsTime = now;
            }

            const pcx = Math.floor((this.player.x - this.worldOffset) / this.chunkSize);
            const pcz = Math.floor((this.player.z - this.worldOffset) / this.chunkSize);

            document.getElementById('fps').textContent = this.fps;
            document.getElementById('frame-time').textContent = (1000 / Math.max(1, this.fps)).toFixed(1) + ' ms';
            document.getElementById('player-pos').textContent =
                `(${this.player.x.toFixed(0)}, ${this.player.y.toFixed(0)}, ${this.player.z.toFixed(0)})`;
            document.getElementById('player-chunk').textContent = `(${pcx}, ${pcz})`;
            document.getElementById('on-ground').textContent = this.player.onGround ? 'Yes' : 'No';
            document.getElementById('flying-status').textContent = this.player.flying ? '‚úàÔ∏è Yes' : 'No';
            document.getElementById('flying-status').classList.toggle('flying', this.player.flying);
            document.getElementById('chunk-count').textContent = this.loadedChunks.size.toLocaleString();
            document.getElementById('voxel-count').textContent = this.engine.getVoxelCount().toLocaleString();
            document.getElementById('brick-count').textContent = this.engine.getBrickCount().toLocaleString();
            document.getElementById('memory-usage').textContent = this.engine.getMemoryUsage().totalMB.toFixed(2) + ' MB';
        }

        run() {
            let lastTime = performance.now();

            const loop = () => {
                const now = performance.now();
                const dt = Math.min((now - lastTime) / 1000, 0.1);
                lastTime = now;

                this._updatePlayer(dt);
                // No dynamic chunk loading - everything is preloaded!
                this.engine.render();
                this._updateStats();

                requestAnimationFrame(loop);
            };

            loop();
        }
    }

    // ============================================================
    // Start
    // ============================================================
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            const game = new VoxelGame('canvas');
            await game.init();
            game.run();
        } catch (err) {
            console.error(err);
            document.getElementById('loading-text').textContent = 'Error: ' + err.message;
            document.getElementById('loading-text').style.color = '#ff6b6b';
        }
    });
    </script>
</body>
</html>
